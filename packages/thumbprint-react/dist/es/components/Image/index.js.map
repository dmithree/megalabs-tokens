{"version":3,"file":"index.js","sources":["../../../../components/Image/index.tsx"],"sourcesContent":["import React, { useState, forwardRef, useEffect } from 'react';\nimport find from 'lodash/find';\nimport classNames from 'classnames';\nimport warning from 'warning';\nimport { useInView } from 'react-intersection-observer';\nimport scrollparent from './get-scroll-parent';\nimport canUseDOM from '../../utils/can-use-dom';\nimport styles from './index.module.scss';\n\n// --------------------------------------------------------------------------------------------\n// Steps in rendering Image\n//\n// 1. Picture is rendered without src, srcSets, and with a padding-top placholder on the <img>\n// based on the containerAspectRatio.\n// 2. The \"sizes\" attr is calculated on initial render to determine width of image.\n// 3. When lazyload is triggered the src and scrSet props are populated based on the sizes value.\n// 4. The image is set to opacity:0 to start to prevent flash of alt text\n// 5. The image onLoad and onError events remove padding-top placholder and sets opacity to 1.\n// --------------------------------------------------------------------------------------------\n\ntype ImageSource = {\n    type: 'image/webp' | 'image/jpeg' | 'image/png' | 'image/gif';\n    srcSet: string;\n};\n\ninterface ImagePropTypes {\n    /**\n     * If `sources` is provided, this image will be loaded by search engines and lazy-loaded for\n     * users on browsers that don't support responsive images. If `sources` is not provided, this\n     * image will be lazy-loaded.\n     */\n    src: string;\n    /**\n     * Allows the browser to choose the best file format and image size based on the device screen\n     * density and the width of the rendered image.\n     */\n    sources?: ImageSource[];\n    alt?: string;\n    /**\n     * Crops the image at the provided height. The `objectFit` and `objectPosition` props can be\n     * used to control how the image is cropped.\n     */\n    height?: string;\n    /**\n     * Creates a [placeholder box](https://css-tricks.com/aspect-ratio-boxes/) for the image.\n     * The placeholder prevents the browser scroll from jumping when the image is lazy-loaded.\n     */\n    containerAspectRatio?: number;\n    /**\n     * Disables lazy-loading and overrides the default calculation of the `sizes` attribute.\n     * Primarily for important images in a server-side rendered environment that must be\n     * loaded before JavaScript is parsed and executed on the client. The value gets used\n     * as the `sizes` attribute. [See allowable values](https://mzl.la/2Hh6neO).\n     */\n    forceEarlyRender?: React.ImgHTMLAttributes<HTMLImageElement>['sizes'];\n    /**\n     * Provides control over how the image should be resized to fit the container. This controls the\n     * `object-fit` CSS property. It is only useful if `height` is used to \"crop\" the image.\n     */\n    objectFit?: 'cover' | 'contain';\n    /**\n     * Provides control over how the image position in the container. This controls the\n     * `object-position` CSS property. It is only useful if `height` is used to \"crop\" the image.\n     */\n    objectPosition?: 'top' | 'center' | 'bottom' | 'left' | 'right';\n    className?: string;\n}\n\ntype ObjectFitPropsType = {\n    style?: {\n        // Not using React.CSSProperties types for these two, because we use a restricted subset.\n        objectFit?: 'cover' | 'contain';\n        objectPosition?: 'top' | 'center' | 'bottom' | 'left' | 'right';\n        fontFamily?: React.CSSProperties['fontFamily'];\n    };\n};\n\ntype AspectRatioBoxPropsType = {\n    style?: {\n        paddingTop?: React.CSSProperties['paddingTop'];\n        overflow?: React.CSSProperties['overflow'];\n        height?: React.CSSProperties['height'];\n    };\n};\n\nconst Image = forwardRef<HTMLElement, ImagePropTypes>((props: ImagePropTypes, outerRef) => {\n    const {\n        src,\n        sources = [],\n        height,\n        containerAspectRatio,\n        objectFit = 'cover',\n        objectPosition = 'center',\n        alt = '',\n        className,\n        forceEarlyRender = null,\n        ...rest\n    } = props;\n\n    // The outermost DOM node that this component references. We use `useState` instead of\n    // `useRef` because callback refs allow us to add more than one `ref` to a DOM node.\n    const [containerRef, setContainerRef] = useState<Element | null>(null);\n\n    // --------------------------------------------------------------------------------------------\n    // Sizes\n    // --------------------------------------------------------------------------------------------\n\n    // Used by srcSet to determine which image in the list will be requested. This value has to be\n    // calculated client-side because we don't know the viewport width.\n\n    const computeSizes = (): string =>\n        containerRef && containerRef.clientWidth ? `${containerRef.clientWidth}px` : '0px';\n\n    // If `forceEarlyRender` is truthy use that value, otherwise use the computed width.\n    const sizes = forceEarlyRender || computeSizes();\n\n    // --------------------------------------------------------------------------------------------\n    // Lazy-loading: library setup and polyfill\n    // --------------------------------------------------------------------------------------------\n\n    // IntersectionObserver's `root` property identifies the element whose bounds are treated as\n    // the bounding box of the viewport for this element. By default, it uses `window`. Instead\n    // of using the default, we use the nearest scrollable parent. This is the same approach that\n    // React Waypoint and lazysizes use. The React Waypoint README explains this concept well:\n    // https://git.io/fj00H\n\n    const parent = canUseDOM && containerRef ? scrollparent(containerRef) : null;\n    const root = parent && (parent.tagName === 'HTML' || parent.tagName === 'BODY') ? null : parent;\n\n    // `shouldLoadImage` becomes `true` when the lazy-loading functionality decides that we should\n    // load the image.\n    const [inViewRef, isInView] = useInView({\n        root,\n        rootMargin: '100px',\n        triggerOnce: true,\n    });\n\n    const [browserSupportIntersectionObserver, setBrowserSupportIntersectionObserver] = useState(\n        canUseDOM && typeof window.IntersectionObserver !== 'undefined',\n    );\n\n    // Loads the `IntersectionObserver` polyfill asynchronously on browsers that don't support it.\n    if (canUseDOM && typeof window.IntersectionObserver === 'undefined') {\n        import('intersection-observer').then(() => {\n            setBrowserSupportIntersectionObserver(true);\n        });\n    }\n\n    // If `forceEarlyRender` is truthy, bypass lazy loading and load the image.\n    const shouldLoadImage = isInView || forceEarlyRender;\n\n    // --------------------------------------------------------------------------------------------\n    // Object Fit: polyfill and CSS styles\n    // --------------------------------------------------------------------------------------------\n\n    const objectFitProps: ObjectFitPropsType = {};\n\n    const shouldObjectFit = !!height;\n    const shouldPolyfillObjectFit =\n        canUseDOM &&\n        document.documentElement &&\n        document.documentElement.style &&\n        'objectFit' in document.documentElement.style !== true;\n\n    warning(\n        (!height && !containerAspectRatio) ||\n            (height && !containerAspectRatio) ||\n            (!height && containerAspectRatio),\n        'You can pass either a `height` or `containerAspectRatio` to the `Image` component, but not both.',\n    );\n\n    useEffect(() => {\n        // We polyfill `object-fit` for browsers that don't support it. We only do it if we're\n        // using a `height` or `containerAspectRatio`. The `shouldLoadImage` variable ensures\n        // that we don't try to polyfill the image before the `src` exists. This can happy\n        // when we lazy-load.\n        if (shouldObjectFit && containerRef && shouldLoadImage && shouldPolyfillObjectFit) {\n            import('object-fit-images').then(({ default: ObjectFitImages }) => {\n                ObjectFitImages(containerRef.querySelector('img'));\n            });\n        }\n    }, [shouldObjectFit, containerRef, shouldLoadImage, shouldPolyfillObjectFit]);\n\n    if (shouldObjectFit) {\n        objectFitProps.style = {\n            objectFit,\n            objectPosition,\n        };\n        if (shouldPolyfillObjectFit) {\n            // Weird, but this is how the polyfill knows what to do with the image in IE.\n            objectFitProps.style.fontFamily = `\"object-fit: ${objectFit}; object-position: ${objectPosition}\"`;\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Image Aspect Ratio used for image placeholder\n    // --------------------------------------------------------------------------------------------\n\n    const aspectRatioBoxProps: AspectRatioBoxPropsType = {};\n\n    if (containerAspectRatio) {\n        // This ensures that lazy-loaded images don't cause the browser scroll to jump once the\n        // image has loaded. It uses the following technique:\n        // https://css-tricks.com/aspect-ratio-boxes/\n        const h = 100000;\n        const w = h * containerAspectRatio;\n\n        aspectRatioBoxProps.style = {\n            paddingTop: `${(h / w) * 100}%`,\n            overflow: 'hidden', // Prevents alt text from taking up space before `src` is populated\n            height: 0,\n        };\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Sources and srcSets\n    // --------------------------------------------------------------------------------------------\n\n    // We separate `webp` from the `jpeg`/`png` so that we can apply the `imgTagSource` directly\n    // onto the `img` tag. While this makes the code messier, it is needed to work around a bug in\n    // Safari:\n    // - https://bugs.webkit.org/show_bug.cgi?id=190031\n    // - https://bugs.webkit.org/show_bug.cgi?id=177068\n\n    const webpSource = find(sources, s => s.type === 'image/webp');\n    const imgTagSource = find(sources, s => s.type === 'image/jpeg' || s.type === 'image/png');\n\n    // --------------------------------------------------------------------------------------------\n    // Image load and error states\n    // --------------------------------------------------------------------------------------------\n\n    const [isLoaded, setIsLoaded] = useState(false);\n    const [isError, setIsError] = useState(false);\n\n    return (\n        <>\n            <picture\n                {...rest}\n                className={classNames(styles.picture, className)}\n                ref={(el): void => {\n                    // Using a callback `ref` on this `picture` allows us to have multiple `ref`s on one\n                    // element.\n                    setContainerRef(el);\n\n                    // We don't want to turn on the `react-intersection-observer` functionality until\n                    // the polyfill is done loading.\n                    if (browserSupportIntersectionObserver) {\n                        inViewRef(el);\n                    }\n\n                    // `outerRef` is the potential forwarded `ref` passed in from a consumer.\n                    // Not all refs are callable functions, so only try and call it if it is.\n                    if (typeof outerRef === 'function') {\n                        outerRef(el);\n                    }\n                }}\n            >\n                {webpSource && (\n                    <source\n                        type={webpSource.type}\n                        // Only add this attribute if lazyload has been triggered.\n                        srcSet={shouldLoadImage ? webpSource.srcSet : undefined}\n                        sizes={sizes}\n                    />\n                )}\n                <img\n                    // The order of `sizes`, `srcSet`, and `src` is important to work around a bug in\n                    // Safari. Once the bug is fixed, we should simplify this by using `src` on the\n                    // `img` tag and using `source` tags.\n                    sizes={sizes}\n                    // Only add this attribute if lazyload has been triggered.\n                    srcSet={shouldLoadImage && imgTagSource ? imgTagSource.srcSet : undefined}\n                    // Only add this attribute if lazyload has been triggered.\n                    src={shouldLoadImage ? src : undefined}\n                    // Height is generally only used for full-width hero images.\n                    height={height}\n                    alt={alt}\n                    // Adds object fit values if specified and adds/removes placeholder padding.\n                    // For SSR we want this to fire instantly.\n                    style={{\n                        ...(shouldObjectFit ? objectFitProps.style : {}),\n                        ...(isLoaded || isError || forceEarlyRender\n                            ? {}\n                            : aspectRatioBoxProps.style),\n                    }}\n                    onLoad={(): void => {\n                        setIsLoaded(true);\n                    }}\n                    onError={(): void => {\n                        setIsError(true);\n                    }}\n                    className={classNames({\n                        // Opacity to 0, prevents flash of alt text when `height` prop used\n                        [styles.imageStart]: true,\n                        // Opacity to 1 to reveal image or show alt text on error\n                        // For SSR we want this to fire instantly.\n                        [styles.imageEnd]: isLoaded || isError || forceEarlyRender,\n                    })}\n                />\n            </picture>\n            {!forceEarlyRender && (\n                <noscript>\n                    <img src={src} alt={alt} />\n                </noscript>\n            )}\n        </>\n    );\n});\n\n// Needed because of the `forwardRef`.\nImage.displayName = 'Image';\n\nexport default Image;\n"],"names":["Image","forwardRef","props","outerRef","src","sources","height","containerAspectRatio","objectFit","objectPosition","alt","className","forceEarlyRender","rest","useState","containerRef","setContainerRef","computeSizes","clientWidth","sizes","parent","canUseDOM","scrollparent","root","tagName","useInView","rootMargin","triggerOnce","inViewRef","isInView","window","IntersectionObserver","browserSupportIntersectionObserver","setBrowserSupportIntersectionObserver","then","shouldLoadImage","objectFitProps","shouldObjectFit","shouldPolyfillObjectFit","document","documentElement","style","warning","useEffect","ObjectFitImages","default","querySelector","fontFamily","aspectRatioBoxProps","h","w","paddingTop","overflow","webpSource","find","s","type","imgTagSource","isLoaded","setIsLoaded","isError","setIsError","classNames","styles","picture","el","srcSet","undefined","imageStart","imageEnd","displayName"],"mappings":"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"}