{"version":3,"file":"react-intersection-observer.umd.min.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/invariant/invariant.js","../src/intersection.ts","../src/InView.tsx","../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/useInView.tsx"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar NODE_ENV = process.env.NODE_ENV;\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","import invariant from 'invariant'\nimport { ObserverInstance, ObserverInstanceCallback } from './index'\n\nconst INSTANCE_MAP: Map<Element, ObserverInstance> = new Map()\nconst OBSERVER_MAP: Map<string, IntersectionObserver> = new Map()\nconst ROOT_IDS: Map<Element, string> = new Map()\n\nlet consecutiveRootId = 0\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return ''\n  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root)\n  consecutiveRootId += 1\n  ROOT_IDS.set(root, consecutiveRootId.toString())\n  return ROOT_IDS.get(root) + '_'\n}\n\n/**\n * Monitor element, and trigger callback when element becomes inView\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering\n * @param options.root {HTMLElement}\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n  if (!options.threshold) options.threshold = 0\n  const { root, rootMargin, threshold } = options\n  // Validate that the element is not being used in another <Observer />\n  invariant(\n    !INSTANCE_MAP.has(element),\n    \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\",\n    element,\n  )\n  /* istanbul ignore if */\n  if (!element) return\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  // An observer with the same options can be reused, so lets use this fact\n  let observerId: string =\n    getRootId(root) +\n    (rootMargin\n      ? `${threshold.toString()}_${rootMargin}`\n      : threshold.toString())\n\n  let observerInstance = OBSERVER_MAP.get(observerId)\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options)\n    /* istanbul ignore else  */\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance)\n  }\n\n  const instance: ObserverInstance = {\n    callback,\n    element,\n    inView: false,\n    observerId,\n    observer: observerInstance,\n    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.\n    thresholds:\n      observerInstance.thresholds ||\n      (Array.isArray(threshold) ? threshold : [threshold]),\n  }\n\n  INSTANCE_MAP.set(element, instance)\n  observerInstance.observe(element)\n\n  return instance\n}\n\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {Element}\n */\nexport function unobserve(element: Element | null) {\n  if (!element) return\n  const instance = INSTANCE_MAP.get(element)\n\n  if (instance) {\n    const { observerId, observer } = instance\n    const { root } = observer\n\n    observer.unobserve(element)\n\n    // Check if we are still observing any elements with the same threshold.\n    let itemsLeft = false\n    // Check if we still have observers configured with the same root.\n    let rootObserved = false\n    /* istanbul ignore else  */\n    if (observerId) {\n      INSTANCE_MAP.forEach((item, key) => {\n        if (key !== element) {\n          if (item.observerId === observerId) {\n            itemsLeft = true\n            rootObserved = true\n          }\n          if (item.observer.root === root) {\n            rootObserved = true\n          }\n        }\n      })\n    }\n    if (!rootObserved && root) ROOT_IDS.delete(root)\n    if (observer && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observer.disconnect()\n    }\n\n    // Remove reference to element\n    INSTANCE_MAP.delete(element)\n  }\n}\n\n/**\n * Destroy all IntersectionObservers currently connected\n **/\nexport function destroy() {\n  OBSERVER_MAP.forEach(observer => {\n    observer.disconnect()\n  })\n\n  OBSERVER_MAP.clear()\n  INSTANCE_MAP.clear()\n  ROOT_IDS.clear()\n  consecutiveRootId = 0\n}\n\nfunction onChange(changes: IntersectionObserverEntry[]) {\n  changes.forEach(intersection => {\n    const { isIntersecting, intersectionRatio, target } = intersection\n    const instance = INSTANCE_MAP.get(target)\n\n    // Firefox can report a negative intersectionRatio when scrolling.\n    /* istanbul ignore else */\n    if (instance && intersectionRatio >= 0) {\n      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n      let inView = instance.thresholds.some(threshold => {\n        return instance.inView\n          ? intersectionRatio > threshold\n          : intersectionRatio >= threshold\n      })\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting\n      }\n\n      instance.inView = inView\n      instance.callback(inView, intersection)\n    }\n  })\n}\n\nexport default {\n  observe,\n  unobserve,\n  destroy,\n}\n","import * as React from 'react'\nimport invariant from 'invariant'\nimport { observe, unobserve } from './intersection'\nimport { IntersectionObserverProps, PlainChildrenProps } from './index'\n\ntype State = {\n  inView: boolean\n  entry?: IntersectionObserverEntry\n}\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function'\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  static displayName = 'InView'\n  static defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n  }\n\n  state: State = {\n    inView: false,\n    entry: undefined,\n  }\n\n  componentDidMount() {\n    /* istanbul ignore else  */\n    if (process.env.NODE_ENV !== 'production') {\n      invariant(\n        this.node,\n        `react-intersection-observer: No DOM node found. Make sure you forward \"ref\" to the root DOM element you want to observe.`,\n      )\n    }\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps, prevState: State) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold\n    ) {\n      unobserve(this.node)\n      this.observeNode()\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node)\n        this.node = null\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node)\n      this.node = null\n    }\n  }\n\n  node: Element | null = null\n\n  observeNode() {\n    if (!this.node) return\n    const { threshold, root, rootMargin } = this.props\n    observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n    })\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) unobserve(this.node)\n    this.node = node ? node : null\n    this.observeNode()\n  }\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    // Only trigger a state update if inView has changed.\n    // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport\n    if (inView !== this.state.inView || inView) {\n      this.setState({ inView, entry })\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry)\n    }\n  }\n\n  render() {\n    const { inView, entry } = this.state\n    if (!isPlainChildren(this.props)) {\n      return this.props.children({ inView, entry, ref: this.handleNode })\n    }\n\n    const {\n      children,\n      as,\n      tag,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      ...props\n    } = this.props\n\n    return React.createElement(\n      as || tag || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    )\n  }\n}\n","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","/* eslint-disable react-hooks/exhaustive-deps */\nimport * as React from 'react'\nimport { observe, unobserve } from './intersection'\nimport { InViewHookResponse, IntersectionOptions } from './index'\n\ntype State = {\n  inView: boolean\n  entry?: IntersectionObserverEntry\n}\n\nexport function useInView(\n  options: IntersectionOptions = {},\n): InViewHookResponse {\n  const [ref, setRef] = React.useState<Element | null | undefined>(null)\n  const [state, setState] = React.useState<State>({\n    inView: false,\n    entry: undefined,\n  })\n\n  React.useEffect(\n    () => {\n      if (!ref) return\n      observe(\n        ref,\n        (inView, intersection) => {\n          setState({ inView, entry: intersection })\n\n          if (inView && options.triggerOnce) {\n            // If it should only trigger once, unobserve the element after it's inView\n            unobserve(ref)\n          }\n        },\n        options,\n      )\n\n      return () => {\n        unobserve(ref)\n      }\n    },\n    [\n      // Only create a new Observer instance if the ref or any of the options have been changed.\n      ref,\n      options.threshold,\n      options.root,\n      options.rootMargin,\n      options.triggerOnce,\n    ],\n  )\n\n  React.useDebugValue(state.inView)\n\n  return [setRef, state.inView, state.entry]\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_assertThisInitialized","self","ReferenceError","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","condition","format","a","b","c","d","e","f","error","undefined","Error","args","argIndex","replace","name","framesToPop","INSTANCE_MAP","Map","OBSERVER_MAP","ROOT_IDS","consecutiveRootId","observe","element","callback","options","threshold","root","rootMargin","invariant","has","observerId","get","set","toString","getRootId","observerInstance","IntersectionObserver","onChange","instance","inView","observer","thresholds","Array","isArray","unobserve","itemsLeft","rootObserved","forEach","item","disconnect","changes","intersection","isIntersecting","intersectionRatio","some","InView","subClass","superClass","entry","node","_this","observeNode","state","setState","props","create","constructor","__proto__","componentDidMount","componentDidUpdate","prevProps","prevState","triggerOnce","componentWillUnmount","handleChange","render","children","isPlainChildren","ref","handleNode","as","tag","excluded","sourceKeys","keys","indexOf","React","setRef"],"mappings":"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"}